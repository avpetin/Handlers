Задача 1. Генерация никнеймов
Описание
Предположим, что для реализации сервиса по подбору никнеймов вы разработали генератор случайного текста:
    public static String generateText(String letters, int length) {
        Random random = new Random();
        StringBuilder text = new StringBuilder();
        for (int i = 0; i < length; i++) {
            text.append(letters.charAt(random.nextInt(letters.length())));
        }
        return text.toString();
    }
Для генерации 100 000 коротких слов вы использовали:
        Random random = new Random();
        String[] texts = new String[100_000];
        for (int i = 0; i < texts.length; i++) {
            texts[i] = generateText("abc", 3 + random.nextInt(3));
        }
Пользователь может выбрать из них только те, которые соответствуют критериям «красивого» никнейма, а именно:
сгенерированное слово является палиндромом, т. е. читается одинаково как слева направо, так и справа налево, например, abba;
сгенерированное слово состоит из одной и той же буквы, например, aaa;
буквы в слове идут по возрастанию: сначала все a (при наличии), затем все b (при наличии), затем все c и т. д. Например, aaccc.
Вы хотите подсчитать, сколько «красивых» слов встречается среди сгенерированных длиной 3, 4, 5, для чего заводите три счётчика в статических полях. Проверка каждого критерия должна осуществляться в отдельном потоке.
После завершения всех трёх потоков выведите сообщение вида:
Красивых слов с длиной 3: 100 шт
Красивых слов с длиной 4: 104 шт
Красивых слов с длиной 5: 90 шт
Не используйте при этом synchronized, посмотрите в сторону AtomicInteger.
Реализация
1. Создайте генератор текстов и сгенерируйте набор из 100 000 текстов, используя код из описания задачи.
2. Заведите в статических полях три счётчика — по одному для длин 3, 4 и 5.
3. Заведите три потока — по одному на каждый критерий «красоты» слова. Каждый поток проверяет все тексты на «красоту» и увеличивает счётчик нужной длины, если текст соответствует критериям.
4. После окончания работы всех потоков выведите результаты на экран.
В качестве решения отправьте на проверку ссылку на репозиторий с решением.

Задача 1. Программа-анализатор
Описание
Ваш коллега из первой задачи до сих пор ломает голову над математической статистикой. Благодаря уже известному вам генератору, он создаёт из символов "abc" 10 000 текстов, длиной 100 000 каждый.
Генератор текстов.
Теперь его интересует, как бы выглядел текст, в котором содержится максимальное количество:
символов 'a';
символов 'b';
символов 'c'.
Попробуем решить эту задачу многопоточно: чтобы за анализ строк на предмет максимального количества каждого из трёх символов отвечал отдельный поток.
То есть за поиск строки с самым большим количеством символов 'a' отвечал бы один поток, за поиск с самым большим количеством 'b' — второй и за 'c' — третий.
Но сгенерировать все тексты, сохранить их в массив и затем пройтись по ним неправильно, т. к. суммарно в текстах было бы около 1 млрд. символов, что привело бы к избыточному расходу памяти. Мы можем пойти другим путём и распараллелить этап создания строк и этапы их анализа.
Для этого строки будут генерироваться в отдельном потоке и заполнять блокирующие очереди, максимальный размер которых ограничим 100 строками.
Очереди нужно будет сделать по одной для каждого из трёх анализирующих потоков, т. к. строка должна быть обработана каждым таким потоком.
Подсказка.
Реализация
1. Создайте в статических полях три потокобезопасные блокирующие очереди.
2. Создайте поток, который наполнял бы эти очереди текстами.
3. Создайте по потоку для каждого из трёх символов 'a', 'b' и 'c', которые разбирали бы свою очередь и выполняли подсчёты.
Не изменяйте код программы, описанный в условиях задачи. В качестве результата отправьте на проверку ссылку на репозиторий с решением.

https://github.com/netology-code/jd-homeworks/blob/video/tdd_ddd/task1/README.md

Задача 1. Разработка через тестирование
Описание
Так как мы прошли Test Driven Development, попытаемся разработать минимальную программу с помощью этого подхода.
Вам нужно разработать класс телефонной книги, которая позволяет:
add — добавить имя с номером. Метод должен возвращать количество контактов после добавления, при этом гарантируется, что не будут добавляться повторяющиеся имена;
findByNumber — найти имя по номеру без полного перебора;
findByName — найти номер по имени без полного перебора;
printAllNames — вывести все имена в алфавитном порядке без необходимости проводить сортировку.
Реализация
Класс телефонной книги нужно разрабатывать поэтапно — по одному методу за раз. Следуйте техникам TDD. Таким образом, разработка должна проходить по этапам:
1. Создать пустой мавен-проект.
2. Создать пустой класс PhoneBook.
3. Создать пустой класс тестов PhoneBookTest.
4. Сделать коммит с сообщением Initial commit.
5. Создать пустой метод-заглушку add в классе PhoneBook, который только возвращает 0.
6. Создать тест или тесты на метод add в классе тестов PhoneBookTest.
7. Убедиться, что всё компилируется и тесты не проходят. Сделать коммит с сообщением Stub and tests for add.
8. Реализовать метод add так, чтобы все тесты проходили.
9. Сделать коммит с сообщением add implemented.
10. Создать пустой метод-заглушку findByNumber в классе PhoneBook, который только возвращает null.
11. Создать тест или тесты на метод findByNumber в классе тестов PhoneBookTest.
12. Убедиться, что всё компилируется и тесты не проходят. Сделать коммит с сообщением Stub and tests for findByNumber.
13. Реализовать метод findByNumber так, чтобы все тесты проходили.
14. Сделать коммит с сообщением findByNumber implemented.
15. ...
После того, как вся функциональность реализована, сделайте пуш в новый репозиторий. Убедитесь, что все тесты проходят и у вас сделаны все требуемые в задании коммиты.

Курсовой проект "Сетевой чат"
Описание проекта
Вам нужно разработать два приложения для обмена текстовыми сообщениями по сети с помощью консоли (терминала) между двумя и более пользователями.
Первое приложение - сервер чата, должно ожидать подключения пользователей.
Второе приложение - клиент чата, подключается к серверу чата и осуществляет доставку и получение новых сообщений.
Все сообщения должны записываться в file.log как на сервере, так и на клиентах. File.log должен дополняться при каждом запуске, а также при отправленном или полученном сообщении. Выход из чата должен быть осуществлен по команде exit.
Требования к серверу
Установка порта для подключения клиентов через файл настроек (например, settings.txt);
Возможность подключиться к серверу в любой момент и присоединиться к чату;
Отправка новых сообщений клиентам;
Запись всех отправленных через сервер сообщений с указанием имени пользователя и времени отправки.
Требования к клиенту
Выбор имени для участия в чате;
Прочитать настройки приложения из файла настроек - например, номер порта сервера;
Подключение к указанному в настройках серверу;
Для выхода из чата нужно набрать команду выхода - “/exit”;
Каждое сообщение участников должно записываться в текстовый файл - файл логирования. При каждом запуске приложения файл должен дополняться.
Требования в реализации
Сервер должен уметь одновременно ожидать новых пользователей и обрабатывать поступающие сообщения от пользователей;
Использован сборщик пакетов gradle/maven;
Код размещен на github;
Код покрыт unit-тестами.
Шаги реализации:
1. Нарисовать схему приложений;
2. Описать архитектуру приложений (сколько потоков за что отвечают, придумать протокол обмена сообщениями между приложениями);
3. Создать репозиторий проекта на github;
4. Написать сервер;
5. Провести интеграционный тест сервера, например с помощью telnet;
6. Написать клиент;
7. Провести интеграционный тест сервера и клиента;
8. Протестировать сервер при подключении нескольких клиентов;
9. Написать README.md к проекту;
10. Отправить на проверку.




Refactoring & MultiThreading
Легенда
Достаточно часто после того, как прототип проверен (речь о том, что было реализовано на лекции), возникает задача — привести это в должный вид: выделить классы, методы, обеспечить нужную функциональность.
Задача
Необходимо отрефакторить код, рассмотренный на лекции, и применить все знания, которые у вас есть:
1. Выделить класс Server с методами для:
запуска;
обработки конкретного подключения.
2. Реализовать обработку подключений с помощью ThreadPool — выделите фиксированный на 64 потока, и каждое подключение обрабатывайте в потоке из пула.
Так как вы главный архитектор и проектировщик этого класса, то все архитектурные решения принимаете вы, поэтому будьте готовы к критике со стороны проверяющих.
Результат
В качестве результата пришлите ссылку на ваш проект на GitHub в личном кабинете студента на сайте netology.ru.

Handlers* (задача со звёздочкой)
Это необязательная задача, её выполнение не влияет на получение зачёта.
Легенда
Сервер, который вы написали в предыдущей задаче, пока не расширяемый, и его нельзя переиспользовать, т. к. код обработки зашит прямо внутрь сервера.
Попробуйте сделать его полезнее — чтобы в сервер можно было добавлять обработчиков на определённые шаблоны путей.
Это значит, нужно, чтобы можно было сделать так:
public class Main {
    public static void main(String[] args){
      final var server = new Server();
      // код инициализации сервера (из вашего предыдущего ДЗ)

      // добавление хендлеров (обработчиков)
      server.addHandler("GET", "/messages", new Handler() {
        public void handle(Request request, BufferedOutputStream responseStream) {
          // TODO: handlers code
        }
      });
      server.addHandler("POST", "/messages", new Handler() {
        public void handle(Request request, BufferedOutputStream responseStream) {
          // TODO: handlers code
        }
      });

      server.listen(9999);
    }
}
В итоге на запрос типа GET на путь "/messages" будет вызван первый обработчик, а на запрос типа POST и путь "/messages" будет вызван второй.
Как вы видите, Handler — функциональный интерфейс всего с одним методом. Он может быть заменён на lambda.
Request — это класс, который проектируете вы сами. Для нас важно, чтобы он содержал:
метод запроса, потому что на разные методы можно назначить один и тот же хендлер;
заголовки запроса;
тело запроса, если есть.
BufferedOutputStream берётся путём заворачивания OutputStream socket: new BufferedOutputStream(socket.getOutputStream()).
Задача
Реализуйте требования, указанные в легенде.
Подсказки по реализации.
1. Вы принимаете запрос, парсите его целиком, как мы сделали на лекции, и собираете объект, типа Request.
2. На основании данных из Request вы выбираете хендлер (он может быть только один), который и будет обрабатывать запрос.
3. Все хендлеры должны храниться в полях Server.
4. Самый простой способ хранить хендлеры — это использовать в качестве ключей метод и путь. Можно сделать как Map внутри Map, так и отдельные Map на каждый метод.
5. Поиск хендлера заключается в том, что вы выбираете по нужному методу все зарегистрированные хендлеры, а затем перебираете по пути. Используйте пока точное соответствие: считайте, что у вас все запросы без Query String.
6. Найдя нужный хендлер, достаточно вызвать его метод handle, передав туда Request и BufferedOutputStream.
7. Так как ваш сервер многопоточный, думайте о том, как вы будете безопасно хранить все хендлеры.
8. В качестве Body достаточно передавать InputStream (напоминаем, Body начинается после \r\n\r\n).
Итого: фактически вы решаете задачу поиска элемента в «коллекции» с вызовом его метода.
Результат
Реализуйте новую функциональность в ветке feature/handlers вашего репозитория из домашнего задания 1 и откройте Pull Request.
Так как вы главный архитектор и проектировщик этого, уже более функционального решения, то все архитектурные решения принимать вам, поэтому будьте готовы к критике со стороны проверяющих.
В качестве решения пришлите ссылку на ваш Pull Request на GitHub в личном кабинете студента на сайте netology.ru.
После того, как домашнее задание будет принято, сделайте merge для Pull Request.


Домашнее задание к занятию «1.2. Формы и форматы передачи данных»
Query
Легенда
В рамках изучения Java Core и работы протокола HTTP вы использовали библиотеку HttpClient из состава Apache HttpComponents.
В состав этой библиотеки входит утилитный класс URLEncodedUtils, который и позволяет «парсить» Query String, извлекая параметры.
Необходимо добавить в ваш сервер из предыдущего ДЗ функциональность обработки параметров запроса так, чтобы можно было из объекта типа Request отдельно получать и путь запроса, и параметры из Query String.
Например, это можно сделать в виде метода getQueryParam(String name) и getQueryParams(). Подумайте, что они должны возвращать, исходя из документации на утилитный класс.
Задача
1. Подключите к своему проекту HttpClient.
2. Реализуйте функциональность по обработке параметров из Query.
3. При необходимости доработайте функциональность поиска хендлера так, чтобы учитывался только путь без Query, т. е. хендлер, зарегистрированный на "/messages", обрабатывал и запросы "/messages?last=10".
Результат
Реализуйте новую функциональность в ветке feature/query вашего репозитория из ДЗ 1 и откройте Pull Request.
Так как вы главный архитектор и проектировщик этого, уже более функционального решения, то все архитектурные решения принимать вам, поэтому будьте готовы к критике со стороны проверяющих.
В качестве решения пришлите ссылку на ваш Pull Request на GitHub в личном кабинете студента на сайте netology.ru.
После того, как домашнее задание будет принято, сделайте merge для Pull Request.
x-www-form-urlencoded* (задача со звёздочкой)
Это необязательная задача, её выполнение не влияет на получение зачёта.
Легенда
Необходимо добавить в ваш сервер из предыдущего домашнего задания функциональность обработки тела, оформленного в виде x-www-form-url-encoded запроса так, чтобы можно было из объекта типа Request отдельно получать параметры, переданные в теле запроса.
Например, это можно сделать в виде метода getPostParam(String name) и getPostParams(). Подумайте, что они должны возвращать, исходя из того, что в передаваемой вам форме может быть два параметра с одинаковым именем.
Задача
Реализуйте функциональность по обработке тела запроса, если он представлен в виде x-www-form-urlencoded.
Результат
Реализуйте новую функциональность в ветке feature/form вашего репозитория из предыдущего домашнего и откройте Pull Request.
Так как вы главный архитектор и проектировщик этого, уже более функционального решения, то все архитектурные решения принимать вам, поэтому будьте готовы к критике со стороны проверяющих.
В качестве результата пришлите ссылку на ваш Pull Request на GitHub в личном кабинете студента на сайте netology.ru.
После того, как домашнее задание будет принято, сделайте merge для Pull Request.
multipart/form-data* (задача со звёздочкой)
Это необязательная задача, её выполнение не влияет на получение зачёта.

Легенда
Реализуйте полную функциональность и добавьте поддержку multipart-запросов. Используйте для этого библиотеку FileUpload.
Например, это можно сделать в виде метода getPart(String name) и getParts(). Подумайте, что они должны возвращать, исходя из того, что:
в передаваемой вам форме может быть два параметра с одинаковым именем;
каждый Part может быть как файлом, так и обычным полем.
Это значит, что нужно уметь отличать обычные поля от файлов.
Задача
Реализуйте функциональность по обработке тела запроса, если он представлен в виде multipart/form-data.
Так как вы главный архитектор и проектировщик этого класса, то все архитектурные решения принимать вам, поэтому будьте готовы к критике со стороны проверяющих.
Результат
Реализуйте новую функциональность в ветке feature/multipart вашего репозитория из предыдущего домашнего задания и откройте Pull Request.
Так как вы главный архитектор и проектировщик этого, уже более функционального решения, то все архитектурные решения принимать вам, поэтому будьте готовы к критике со стороны проверяющих.
В качестве решения пришлите ссылку на ваш Pull Request на GitHub в личном кабинете студента на сайте netology.ru.
После того, как домашнее задание будет принято, сделайте merge для Pull Request.
